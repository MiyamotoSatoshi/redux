## API Report File for "react-redux"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="hoist-non-react-statics" />
/// <reference types="react" />

import { Action } from 'redux';
import { AnyAction } from 'redux';
import { unstable_batchedUpdates as batch } from 'react-dom';
import { ClassAttributes } from 'react';
import { ComponentClass } from 'react';
import { ComponentType } from 'react';
import { Context } from 'react';
import { Dispatch } from 'redux';
import { ForwardRefExoticComponent } from 'react';
import hoistStatics from 'hoist-non-react-statics';
import { MemoExoticComponent } from 'react';
import { NamedExoticComponent } from 'react';
import { NonReactStatics } from 'hoist-non-react-statics';
import { default as React_2 } from 'react';
import { ReactNode } from 'react';
import { RefAttributes } from 'react';
import { Store } from 'redux';

// @public (undocumented)
export type AdvancedComponentDecorator<TProps, TOwnProps> = (component: ComponentType<TProps>) => NamedExoticComponent<TOwnProps>;

// @public (undocumented)
export type AnyIfEmpty<T extends object> = keyof T extends never ? any : T;

export { batch }

// @public (undocumented)
export const connect: (mapStateToProps: MapStateToPropsParam<unknown, unknown, DefaultRootState>, mapDispatchToProps: unknown, mergeProps: MergeProps<unknown, unknown, unknown, unknown>, { pure, areStatesEqual, areOwnPropsEqual, areStatePropsEqual, areMergedPropsEqual, ...extraOptions }?: ConnectOptions<DefaultRootState, {}, {}, {}>) => <WC extends ComponentType<    {}>>(WrappedComponent: WC) => (ForwardRefExoticComponent<RefAttributes<unknown>> & {
    WrappedComponent: WC;
} & NonReactStatics<WC, {}>) | ((({
    <TOwnProps>(props: ConnectProps & TOwnProps): JSX.Element;
    displayName: string;
} | MemoExoticComponent<    {
<TOwnProps>(props: ConnectProps & TOwnProps): JSX.Element;
displayName: string;
}>) & {
    WrappedComponent: WC;
}) & NonReactStatics<WC, {}>);

// @public (undocumented)
export function connectAdvanced<S, TProps, TOwnProps, TFactoryOptions extends AnyObject = {}>(selectorFactory: SelectorFactory<S, TProps, unknown, unknown>, { getDisplayName, methodName, shouldHandleStateChanges, forwardRef, context, ...connectOptions }?: ConnectAdvancedOptions & Partial<TFactoryOptions>): <WC extends React_2.ComponentType<{}>>(WrappedComponent: WC) => (React_2.ForwardRefExoticComponent<React_2.RefAttributes<unknown>> & {
    WrappedComponent: WC;
} & hoistStatics.NonReactStatics<WC, {}>) | ((({
    <TOwnProps_1>(props: ConnectProps & TOwnProps_1): JSX.Element;
    displayName: string;
} | React_2.MemoExoticComponent<{
    <TOwnProps_1>(props: ConnectProps & TOwnProps_1): JSX.Element;
    displayName: string;
}>) & {
    WrappedComponent: WC;
}) & hoistStatics.NonReactStatics<WC, {}>);

// @public (undocumented)
export interface ConnectAdvancedOptions {
    // (undocumented)
    context?: typeof ReactReduxContext;
    // (undocumented)
    forwardRef?: boolean;
    // (undocumented)
    getDisplayName?: (name: string) => string;
    // (undocumented)
    methodName?: string;
    // (undocumented)
    pure?: boolean;
    // (undocumented)
    shouldHandleStateChanges?: boolean;
}

// @public (undocumented)
export type ConnectedComponent<C extends ComponentType<any>, P> = NamedExoticComponent<JSX.LibraryManagedAttributes<C, P>> & NonReactStatics<C> & {
    WrappedComponent: C;
};

// @public (undocumented)
export interface ConnectProps {
    // (undocumented)
    context?: ReactReduxContextInstance;
    // (undocumented)
    reactReduxForwardedRef?: React_2.ForwardedRef<unknown>;
    // (undocumented)
    store?: Store;
}

// @public
export function createDispatchHook(context?: Context<ReactReduxContextValue<any, AnyAction> | null>): () => Dispatch<AnyAction>;

// @public
export function createSelectorHook(context?: Context<ReactReduxContextValue<any, AnyAction> | null>): <TState = DefaultRootState, Selected = unknown>(selector: (state: TState) => Selected, equalityFn?: EqualityFn<Selected>) => Selected;

// @public
export function createStoreHook(context?: Context<ReactReduxContextValue<any, AnyAction> | null>): () => Store<any, AnyAction>;

// @public
export interface DefaultRootState {
}

// @public (undocumented)
export interface DispatchProp<A extends Action = AnyAction> {
    // (undocumented)
    dispatch: Dispatch<A>;
}

// @public (undocumented)
export type DistributiveOmit<T, K extends keyof T> = T extends unknown ? Omit_2<T, K> : never;

// @public (undocumented)
export type EqualityFn<T> = (a: T | undefined, b: T | undefined) => boolean;

// @public (undocumented)
export type FixTypeLater = any;

// @public (undocumented)
export type GetProps<C> = C extends ComponentType<infer P> ? C extends ComponentClass<P> ? ClassAttributes<InstanceType<C>> & P : P : never;

// @public (undocumented)
export type HandleThunkActionCreator<TActionCreator> = TActionCreator extends (...args: any[]) => any ? InferThunkActionCreatorType<TActionCreator> : TActionCreator;

// @public (undocumented)
export type InferableComponentEnhancer<TInjectedProps> = InferableComponentEnhancerWithProps<TInjectedProps, {}>;

// @public (undocumented)
export type InferableComponentEnhancerWithProps<TInjectedProps, TNeedsProps> = <C extends ComponentType<Matching<TInjectedProps, GetProps<C>>>>(component: C) => ConnectedComponent<C, DistributiveOmit<GetProps<C>, keyof Shared<TInjectedProps, GetProps<C>>> & TNeedsProps>;

// @public (undocumented)
export type InferThunkActionCreatorType<TActionCreator extends (...args: any[]) => any> = TActionCreator extends (...args: infer TParams) => (...args: any[]) => infer TReturn ? (...args: TParams) => TReturn : TActionCreator;

// @public (undocumented)
export type MapDispatchToProps<TDispatchProps, TOwnProps> = MapDispatchToPropsFunction<TDispatchProps, TOwnProps> | TDispatchProps;

// @public (undocumented)
export type MapDispatchToPropsFactory<TDispatchProps, TOwnProps> = (dispatch: Dispatch<Action>, ownProps: TOwnProps) => MapDispatchToPropsFunction<TDispatchProps, TOwnProps>;

// @public (undocumented)
export type MapDispatchToPropsFunction<TDispatchProps, TOwnProps> = (dispatch: Dispatch<Action>, ownProps: TOwnProps) => TDispatchProps;

// @public (undocumented)
export type MapDispatchToPropsNonObject<TDispatchProps, TOwnProps> = MapDispatchToPropsFactory<TDispatchProps, TOwnProps> | MapDispatchToPropsFunction<TDispatchProps, TOwnProps>;

// @public (undocumented)
export type MapDispatchToPropsParam<TDispatchProps, TOwnProps> = MapDispatchToPropsFactory<TDispatchProps, TOwnProps> | MapDispatchToProps<TDispatchProps, TOwnProps>;

// @public (undocumented)
export type MapStateToProps<TStateProps, TOwnProps, State = DefaultRootState> = (state: State, ownProps: TOwnProps) => TStateProps;

// @public (undocumented)
export type MapStateToPropsFactory<TStateProps, TOwnProps, State = DefaultRootState> = (initialState: State, ownProps: TOwnProps) => MapStateToProps<TStateProps, TOwnProps, State>;

// @public (undocumented)
export type MapStateToPropsParam<TStateProps, TOwnProps, State = DefaultRootState> = MapStateToPropsFactory<TStateProps, TOwnProps, State> | MapStateToProps<TStateProps, TOwnProps, State> | null | undefined;

// @public
export type Matching<InjectedProps, DecorationTargetProps> = {
    [P in keyof DecorationTargetProps]: P extends keyof InjectedProps ? InjectedProps[P] extends DecorationTargetProps[P] ? DecorationTargetProps[P] : InjectedProps[P] : DecorationTargetProps[P];
};

// @public (undocumented)
export type MergeProps<TStateProps, TDispatchProps, TOwnProps, TMergedProps> = (stateProps: TStateProps, dispatchProps: TDispatchProps, ownProps: TOwnProps) => TMergedProps;

// @public (undocumented)
type Omit_2<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export { Omit_2 as Omit }

// @public (undocumented)
export function Provider({ store, context, children }: ProviderProps): JSX.Element;

// @public (undocumented)
export interface ProviderProps<A extends Action = AnyAction> {
    // (undocumented)
    children: ReactNode;
    context?: Context<ReactReduxContextValue>;
    store: Store<FixTypeLater, A>;
}

// @public (undocumented)
export const ReactReduxContext: React_2.Context<ReactReduxContextValue<any, AnyAction> | null>;

// @public (undocumented)
export interface ReactReduxContextValue<SS = FixTypeLater, A extends Action = AnyAction> {
    // (undocumented)
    store: Store<SS, A>;
    // (undocumented)
    subscription: Subscription;
}

// @public (undocumented)
export type ResolveArrayThunks<TDispatchProps extends ReadonlyArray<any>> = TDispatchProps extends [
infer A1,
infer A2,
infer A3,
infer A4,
infer A5,
infer A6,
infer A7,
infer A8,
infer A9
] ? [
HandleThunkActionCreator<A1>,
HandleThunkActionCreator<A2>,
HandleThunkActionCreator<A3>,
HandleThunkActionCreator<A4>,
HandleThunkActionCreator<A5>,
HandleThunkActionCreator<A6>,
HandleThunkActionCreator<A7>,
HandleThunkActionCreator<A8>,
HandleThunkActionCreator<A9>
] : TDispatchProps extends [
infer A1,
infer A2,
infer A3,
infer A4,
infer A5,
infer A6,
infer A7,
infer A8
] ? [
HandleThunkActionCreator<A1>,
HandleThunkActionCreator<A2>,
HandleThunkActionCreator<A3>,
HandleThunkActionCreator<A4>,
HandleThunkActionCreator<A5>,
HandleThunkActionCreator<A6>,
HandleThunkActionCreator<A7>,
HandleThunkActionCreator<A8>
] : TDispatchProps extends [
infer A1,
infer A2,
infer A3,
infer A4,
infer A5,
infer A6,
infer A7
] ? [
HandleThunkActionCreator<A1>,
HandleThunkActionCreator<A2>,
HandleThunkActionCreator<A3>,
HandleThunkActionCreator<A4>,
HandleThunkActionCreator<A5>,
HandleThunkActionCreator<A6>,
HandleThunkActionCreator<A7>
] : TDispatchProps extends [
infer A1,
infer A2,
infer A3,
infer A4,
infer A5,
infer A6
] ? [
HandleThunkActionCreator<A1>,
HandleThunkActionCreator<A2>,
HandleThunkActionCreator<A3>,
HandleThunkActionCreator<A4>,
HandleThunkActionCreator<A5>,
HandleThunkActionCreator<A6>
] : TDispatchProps extends [infer A1, infer A2, infer A3, infer A4, infer A5] ? [
HandleThunkActionCreator<A1>,
HandleThunkActionCreator<A2>,
HandleThunkActionCreator<A3>,
HandleThunkActionCreator<A4>,
HandleThunkActionCreator<A5>
] : TDispatchProps extends [infer A1, infer A2, infer A3, infer A4] ? [
HandleThunkActionCreator<A1>,
HandleThunkActionCreator<A2>,
HandleThunkActionCreator<A3>,
HandleThunkActionCreator<A4>
] : TDispatchProps extends [infer A1, infer A2, infer A3] ? [
HandleThunkActionCreator<A1>,
HandleThunkActionCreator<A2>,
HandleThunkActionCreator<A3>
] : TDispatchProps extends [infer A1, infer A2] ? [HandleThunkActionCreator<A1>, HandleThunkActionCreator<A2>] : TDispatchProps extends [infer A1] ? [HandleThunkActionCreator<A1>] : TDispatchProps extends Array<infer A> ? Array<HandleThunkActionCreator<A>> : TDispatchProps extends ReadonlyArray<infer A> ? ReadonlyArray<HandleThunkActionCreator<A>> : never;

// @public (undocumented)
export type ResolveThunks<TDispatchProps> = TDispatchProps extends {
    [key: string]: any;
} ? {
    [C in keyof TDispatchProps]: HandleThunkActionCreator<TDispatchProps[C]>;
} : TDispatchProps;

// @public (undocumented)
export type RootStateOrAny = AnyIfEmpty<DefaultRootState>;

// @public (undocumented)
export type Selector<S, TProps, TOwnProps = null> = TOwnProps extends null | undefined ? (state: S) => TProps : (state: S, ownProps: TOwnProps) => TProps;

// @public (undocumented)
export type SelectorFactory<S, TProps, TOwnProps, TFactoryOptions> = (dispatch: Dispatch<Action>, factoryOptions: TFactoryOptions) => Selector<S, TProps, TOwnProps>;

// @public (undocumented)
export function shallowEqual(objA: any, objB: any): boolean;

// @public
export type Shared<InjectedProps, DecorationTargetProps> = {
    [P in Extract<keyof InjectedProps, keyof DecorationTargetProps>]?: InjectedProps[P] extends DecorationTargetProps[P] ? DecorationTargetProps[P] : never;
};

// @public
export interface TypedUseSelectorHook<TState> {
    // (undocumented)
    <TSelected>(selector: (state: TState) => TSelected, equalityFn?: (left: TSelected, right: TSelected) => boolean): TSelected;
}

// @public
export const useDispatch: () => Dispatch<AnyAction>;

// @public
export const useSelector: <TState = DefaultRootState, Selected = unknown>(selector: (state: TState) => Selected, equalityFn?: EqualityFn<Selected> | undefined) => Selected;

// @public
export const useStore: () => Store<any, AnyAction>;

// (No @packageDocumentation comment for this package)

```
